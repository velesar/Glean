"""
Report Generators

Generate digests, changelogs, and summaries.
"""

from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Optional
from pathlib import Path

from src.database import Database


@dataclass
class ReportStats:
    """Statistics for a report period."""
    new_tools: int
    updated_tools: int
    total_approved: int
    total_rejected: int
    total_claims: int


def generate_weekly_digest(db: Database, weeks_back: int = 1) -> str:
    """Generate a weekly digest in Markdown format.

    Args:
        db: Database connection
        weeks_back: How many weeks back to report (1 = last week)

    Returns:
        Markdown formatted report string
    """
    conn = db.connect()

    # Calculate date range
    end_date = datetime.now()
    start_date = end_date - timedelta(weeks=weeks_back)

    # Get newly approved tools in this period
    new_tools = conn.execute(
        """SELECT t.*,
                  (SELECT COUNT(*) FROM claims WHERE tool_id = t.id) as claim_count
           FROM tools t
           WHERE t.status = 'approved'
             AND t.reviewed_at >= ?
           ORDER BY t.relevance_score DESC""",
        (start_date.isoformat(),)
    ).fetchall()

    # Get changelog entries (updates to existing tools)
    changes = conn.execute(
        """SELECT c.*, t.name as tool_name, t.url as tool_url
           FROM changelog c
           JOIN tools t ON c.tool_id = t.id
           WHERE c.detected_at >= ?
             AND c.change_type != 'new'
           ORDER BY c.detected_at DESC""",
        (start_date.isoformat(),)
    ).fetchall()

    # Get overall stats
    total_approved = conn.execute(
        "SELECT COUNT(*) FROM tools WHERE status = 'approved'"
    ).fetchone()[0]

    total_in_review = conn.execute(
        "SELECT COUNT(*) FROM tools WHERE status = 'review'"
    ).fetchone()[0]

    # Build report
    lines = []
    lines.append(f"# Glean Weekly Digest")
    lines.append(f"")
    lines.append(f"**Period:** {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}")
    lines.append(f"**Generated:** {end_date.strftime('%Y-%m-%d %H:%M')}")
    lines.append(f"")

    # Summary stats
    lines.append(f"## Summary")
    lines.append(f"")
    lines.append(f"- **New tools approved:** {len(new_tools)}")
    lines.append(f"- **Updates detected:** {len(changes)}")
    lines.append(f"- **Total approved tools:** {total_approved}")
    lines.append(f"- **Tools pending review:** {total_in_review}")
    lines.append(f"")

    # New tools section
    if new_tools:
        lines.append(f"## New Tools")
        lines.append(f"")
        for tool in new_tools:
            tool = dict(tool)
            score = tool.get('relevance_score')
            score_str = f" (relevance: {score:.0%})" if score else ""
            url_str = f" - {tool['url']}" if tool.get('url') else ""

            lines.append(f"### {tool['name']}{score_str}")
            lines.append(f"")
            if tool.get('url'):
                lines.append(f"**URL:** {tool['url']}")
            if tool.get('category'):
                lines.append(f"**Category:** {tool['category']}")
            if tool.get('description'):
                lines.append(f"")
                lines.append(f"{tool['description']}")

            # Get claims for this tool
            claims = db.get_claims_for_tool(tool['id'])
            if claims:
                lines.append(f"")
                lines.append(f"**Key claims:**")
                for claim in claims[:3]:
                    lines.append(f"- {claim['content'][:100]}")

            lines.append(f"")
    else:
        lines.append(f"## New Tools")
        lines.append(f"")
        lines.append(f"*No new tools approved this period.*")
        lines.append(f"")

    # Updates section
    if changes:
        lines.append(f"## Updates & Changes")
        lines.append(f"")

        # Group by tool
        changes_by_tool = {}
        for change in changes:
            change = dict(change)
            tool_name = change['tool_name']
            if tool_name not in changes_by_tool:
                changes_by_tool[tool_name] = []
            changes_by_tool[tool_name].append(change)

        for tool_name, tool_changes in changes_by_tool.items():
            lines.append(f"### {tool_name}")
            lines.append(f"")
            for change in tool_changes:
                date = change['detected_at'][:10]
                lines.append(f"- **{change['change_type']}** ({date}): {change['description']}")
            lines.append(f"")
    else:
        lines.append(f"## Updates & Changes")
        lines.append(f"")
        lines.append(f"*No updates detected this period.*")
        lines.append(f"")

    # Footer
    lines.append(f"---")
    lines.append(f"*Generated by Glean*")

    return '\n'.join(lines)


def generate_changelog(db: Database, days: int = 7, tool_id: int = None) -> str:
    """Generate a changelog in Markdown format.

    Args:
        db: Database connection
        days: Number of days to include
        tool_id: Optional specific tool ID to filter by

    Returns:
        Markdown formatted changelog string
    """
    conn = db.connect()

    start_date = datetime.now() - timedelta(days=days)

    if tool_id:
        changes = conn.execute(
            """SELECT c.*, t.name as tool_name, t.url as tool_url
               FROM changelog c
               JOIN tools t ON c.tool_id = t.id
               WHERE c.tool_id = ?
                 AND c.detected_at >= ?
               ORDER BY c.detected_at DESC""",
            (tool_id, start_date.isoformat())
        ).fetchall()
        tool = db.get_tool(tool_id)
        title = f"Changelog: {tool['name']}" if tool else "Changelog"
    else:
        changes = conn.execute(
            """SELECT c.*, t.name as tool_name, t.url as tool_url
               FROM changelog c
               JOIN tools t ON c.tool_id = t.id
               WHERE c.detected_at >= ?
               ORDER BY c.detected_at DESC""",
            (start_date.isoformat(),)
        ).fetchall()
        title = "Changelog: All Tools"

    # Build report
    lines = []
    lines.append(f"# {title}")
    lines.append(f"")
    lines.append(f"**Period:** Last {days} days")
    lines.append(f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M')}")
    lines.append(f"")

    if changes:
        # Group by date
        changes_by_date = {}
        for change in changes:
            change = dict(change)
            date = change['detected_at'][:10]
            if date not in changes_by_date:
                changes_by_date[date] = []
            changes_by_date[date].append(change)

        for date, date_changes in changes_by_date.items():
            lines.append(f"## {date}")
            lines.append(f"")
            for change in date_changes:
                icon = {
                    'new': 'ðŸ†•',
                    'pricing_change': 'ðŸ’°',
                    'feature_added': 'âœ¨',
                    'feature_removed': 'âŒ',
                    'content_change': 'ðŸ“',
                    'news': 'ðŸ“°',
                }.get(change['change_type'], 'â€¢')

                lines.append(f"- {icon} **{change['tool_name']}** [{change['change_type']}]: {change['description']}")
            lines.append(f"")
    else:
        lines.append(f"*No changes recorded in the last {days} days.*")
        lines.append(f"")

    lines.append(f"---")
    lines.append(f"*Generated by Glean*")

    return '\n'.join(lines)


def generate_tools_index(db: Database) -> str:
    """Generate a Markdown index of all approved tools.

    Returns:
        Markdown formatted tools index
    """
    tools = db.get_tools_by_status('approved')

    lines = []
    lines.append(f"# AI Sales Tools Index")
    lines.append(f"")
    lines.append(f"**Total tools:** {len(tools)}")
    lines.append(f"**Last updated:** {datetime.now().strftime('%Y-%m-%d %H:%M')}")
    lines.append(f"")

    if not tools:
        lines.append(f"*No tools approved yet.*")
        return '\n'.join(lines)

    # Group by category
    by_category = {}
    for tool in tools:
        cat = tool.get('category') or 'other'
        if cat not in by_category:
            by_category[cat] = []
        by_category[cat].append(tool)

    # Sort categories
    category_order = ['prospecting', 'outreach', 'enrichment', 'conversation',
                      'crm', 'scheduling', 'analytics', 'coaching', 'other']

    for cat in category_order:
        if cat not in by_category:
            continue

        cat_tools = by_category[cat]
        lines.append(f"## {cat.title()}")
        lines.append(f"")

        # Sort by relevance score
        cat_tools.sort(key=lambda t: t.get('relevance_score') or 0, reverse=True)

        for tool in cat_tools:
            url = tool.get('url', '')
            if url:
                lines.append(f"- **[{tool['name']}]({url})**")
            else:
                lines.append(f"- **{tool['name']}**")

            if tool.get('description'):
                desc = tool['description'][:100] + ('...' if len(tool['description']) > 100 else '')
                lines.append(f"  {desc}")

        lines.append(f"")

    lines.append(f"---")
    lines.append(f"*Generated by Glean*")

    return '\n'.join(lines)


def save_report(content: str, filename: str, output_dir: str = "reports") -> Path:
    """Save a report to a file.

    Args:
        content: Report content
        filename: Output filename
        output_dir: Output directory

    Returns:
        Path to saved file
    """
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    file_path = output_path / filename
    file_path.write_text(content)

    return file_path
